/**
 * (Internal) Creates a deep observed Proxy recursively, attaching listeners to
 * every object in the nested tree
 * @param {object} root the root object
 * @param {(
 *  target: object,
 *  path: string[],
 *  value: any
 * ) => any} callback the function passed from deepObserve
 * @param {string[]?} treeRoot the path to the current root object in the tree
 * @returns {ProxyHandler<object>}
 */
function observeTree(root, callback, treeRoot = []) {
  for (const key in root) {
    if (root[key] instanceof Object) {
      root[key] = observeTree(root[key], callback, treeRoot.concat([key]))
    }
  }

  return new Proxy(root, createDeepObserver(callback, treeRoot))
}

/**
 * (Internal) The proxy listener generated by createDeepObserver is injected
 * into every object in the tree by observeTree, and in turn calls observeTree
 * to inject itself into the child objects created during the parent's lifetime. 
 * @param {(
 *  target: object,
 *  path: string[],
 *  value: any
 * ) => any} callback the function passed from deepObserve
 * @param {string[]?} treeRoot the path to the current root object in the tree
 * @returns {ProxyHandler}
 */
function createDeepObserver(callback, treeRoot = []) {
  return {
    set(target, key, value) {
      if (!(value instanceof Object)) {
        target[key] = value;
      }

      else {
        target[key] = observeTree(value, callback, treeRoot.concat([key]));
      }

      callback(target, treeRoot.concat([key]), value)
      return true
    },

    deleteProperty(target, key) {
      delete target[key]
      callback(target, treeRoot.concat([key]))
      return true
    },
  }
}

/**
 * Creates a deep/nested Proxy (observable) from a given object.
 * A deep Proxy listens to any changes within a nested object
 * by turning every object in the nested tree into a Proxy.
 * Any changes to objects created within the tree during its lifetime
 * will also trigger the callback.
 * 
 * The Proxy created by this module only listens to changes (set and delete)
 * and executes the callback after the action, therefore it becomes an
 * observable.
 * Modifying the object in the callback function can be implemented,
 * but it is not the intended use case.
 * @param {object} object the object to create an observable from
 * @param {(
 *  target: object,
 *  path: string[],
 *  value: any
 * ) => any} callback the function to call when the object is changed
 * @returns {object}
 */

export function deepObserve(object, callback) {
  // disables setting treeRoot argument in the exposed function
  return observeTree(object, callback)
}

